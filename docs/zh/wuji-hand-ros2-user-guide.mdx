---
title: ROS2 驱动使用指南
---

## 1. 概述

Wuji Hand ROS2 驱动提供了灵巧手在 ROS2 生态系统中的完整支持，主要特性包括：

- **1000Hz 关节状态发布**：高频率实时反馈关节位置和 Effort
- **实时控制接口**：通过 ROS2 Topic 和 Service 控制灵巧手
- **多手支持**：通过命名空间区分，支持同时运行多只灵巧手
- **RViz 可视化**：内置 URDF 模型，支持实时可视化

## 2. 系统要求

### 2.1 软件版本

| 软件 | 最低版本 |
|:-----|:--------|
| Wuji Hand SDK | 1.5.0 |
| 固件 | 1.2.0 |

### 2.2 支持平台

| ROS2 版本 | Ubuntu 版本 |
|:----------|:------------|
| Humble | 22.04 LTS |
| Kilted | 24.04 LTS |

## 3. 安装指南

<Callout type="info">
请确保按照 [系统要求](#2-系统要求) 完成配置后再进行以下步骤。
</Callout>

### 3.1 安装 Wuji Hand SDK

在安装 ROS2 驱动之前，需要先安装 Wuji Hand SDK：

```bash
# 替换 ${SDK_VERSION} 为实际版本号，如 1.5.0
wget https://github.com/wuji-technology/wujihandpy/releases/download/v${SDK_VERSION}/wujihandcpp-${SDK_VERSION}-amd64.deb
sudo apt install ./wujihandcpp-${SDK_VERSION}-amd64.deb
```

### 3.2 安装 ROS2 驱动

ROS2 驱动提供两种安装方式，可根据使用场景选择：

#### 方式一：源码编译（推荐）

**安装依赖**

根据你的 Ubuntu 版本选择对应的命令：

**Ubuntu 22.04 (ROS2 Humble)**

```bash
# 安装 ROS2 Humble 及依赖
sudo apt update
sudo apt install -y ros-humble-ros-base ros-humble-robot-state-publisher \
    ros-humble-rviz2 ros-humble-sensor-msgs ros-humble-std-msgs \
    python3-colcon-common-extensions python3-rosdep
```

**Ubuntu 24.04 (ROS2 Kilted)**

```bash
# 安装 ROS2 Kilted 及依赖
sudo apt update
sudo apt install -y ros-kilted-ros-base ros-kilted-robot-state-publisher \
    ros-kilted-rviz2 ros-kilted-sensor-msgs ros-kilted-std-msgs \
    python3-colcon-common-extensions python3-rosdep
```

**编译与构建**

```bash
# 克隆仓库
git clone https://github.com/wuji-technology/wujihandros2.git
cd wujihandros2

# 拉取 URDF 模型子模块（必须）
git submodule update --init --recursive

# 加载 ROS2 环境，替换 ${distro} 为实际安装的 ROS2 发行版
source /opt/ros/${distro}/setup.bash

# 编译
colcon build

# 加载工作空间
source install/setup.bash
```

<Callout type="warning">
编译前必须执行 `git submodule update --init --recursive` 拉取子模块。`external/wuji-hand-description/` 目录包含编译所需的 URDF 模型。
</Callout>

#### 方式二：Deb 包安装

**Ubuntu 22.04 (ROS2 Humble)**

```bash
# 安装依赖
sudo apt update
sudo apt install -y ros-humble-ros-base ros-humble-robot-state-publisher \
    ros-humble-sensor-msgs ros-humble-std-msgs

# 从 GitHub Releases 下载并安装（替换 ${VERSION} 为实际版本号）
wget https://github.com/wuji-technology/wujihandros2/releases/download/v${VERSION}/ros-humble-wujihand_${VERSION}_amd64.deb
sudo apt install ./ros-humble-wujihand_${VERSION}_amd64.deb
```

**Ubuntu 24.04 (ROS2 Kilted)**

```bash
# 安装依赖
sudo apt update
sudo apt install -y ros-kilted-ros-base ros-kilted-robot-state-publisher \
    ros-kilted-sensor-msgs ros-kilted-std-msgs

# 从 GitHub Releases 下载并安装
wget https://github.com/wuji-technology/wujihandros2/releases/download/v${VERSION}/ros-kilted-wujihand_${VERSION}_amd64.deb
sudo apt install ./ros-kilted-wujihand_${VERSION}_amd64.deb
```

## 4. 快速开始

### 4.1 启动驱动

```bash
#（如使用源码编译）加载 ROS2 环境，替换 ${distro} 为实际安装的 ROS2 发行版
source /opt/ros/${distro}/setup.bash
source install/setup.bash

# 启动驱动
ros2 launch wujihand_bringup wujihand.launch.py
```

启动成功后会看到以下输出：

```text
[wujihand_driver]: Connected to WujiHand (right)
[wujihand_driver]: WujiHand driver started (state: 1000.0 Hz, diagnostics: 10.0 Hz)
```

### 4.2 验证运行状态

打开新终端，查看关节状态：

```bash
# 加载 ROS2 环境，替换 ${distro} 为实际安装的 ROS2 发行版
source /opt/ros/${distro}/setup.bash
source install/setup.bash

ros2 topic echo /hand_0/joint_states --once
```

### 4.3 运行演示

```bash
# 波浪演示：手指依次弯曲伸展
ros2 run wujihand_bringup wave_demo.py
```

### 4.4 启动 RViz 可视化

```bash
ros2 launch wujihand_bringup wujihand.launch.py rviz:=true
```

**运行效果**

![RViz 可视化效果](images/rviz-visualization.png)

## 5. 启动与配置

### 5.1 启动命令

| 命令 | 说明 |
|:-----|:-----|
| `ros2 launch wujihand_bringup wujihand.launch.py` | 仅启动驱动 |
| `ros2 launch wujihand_bringup wujihand.launch.py rviz:=true` | 启动驱动并通过 RViz 可视化 |

### 5.2 可配置参数

<Callout type="info">
左右手类型从硬件自动检测，无需手动指定。
</Callout>

| 参数 | 默认值 | 说明 |
|:-----|:-------|:-----|
| `hand_name` | `hand_0` | 命名空间，用于区分多手。 <br/> 示例：`ros2 launch wujihand_bringup wujihand.launch.py hand_name:=my_hand` |
| `serial_number` | `""` | 设备序列号（空则自动检测） |
| `publish_rate` | `1000.0` | 关节状态发布频率 (Hz) |
| `filter_cutoff_freq` | `10.0` | 低通滤波截止频率 (Hz) |
| `diagnostics_rate` | `10.0` | 诊断信息发布频率 (Hz) |
| `rviz` | `false` | 是否启动 RViz 可视化 |



### 5.3 多手配置

当需要同时控制多只灵巧手时，可通过序列号和命名空间区分。

如果打开新终端，需要重新加载 ROS2 环境
```bash
#（如使用源码编译）加载 ROS2 环境，替换 ${distro} 为实际安装的 ROS2 发行版
source /opt/ros/${distro}/setup.bash
source install/setup.bash
```

```bash
# 终端 1：启动左手
ros2 launch wujihand_bringup wujihand.launch.py \
    hand_name:=left_hand serial_number:=ABC123

# 终端 2：启动右手
ros2 launch wujihand_bringup wujihand.launch.py \
    hand_name:=right_hand serial_number:=DEF456
```

启动后，每只手会拥有独立的话题命名空间：

```text
# 左手话题
/left_hand/joint_states
/left_hand/joint_commands
/left_hand/hand_diagnostics
/left_hand/robot_description
/left_hand/tf
/left_hand/tf_static

# 右手话题
/right_hand/joint_states
/right_hand/joint_commands
/right_hand/hand_diagnostics
/right_hand/robot_description
/right_hand/tf
/right_hand/tf_static
```

### 5.4 关节标识

灵巧手共有 20 个关节（5 根手指 × 4 个关节/手指）。

#### 手指与关节编号

[服务调用](#62-服务调用)使用 `finger_id` 和 `joint_id`：

| 参数 | 值与含义 |
|:-----|:---------|
| `finger_id` | <ul><li>0：拇指</li><li>1：食指</li><li>2：中指</li><li>3：无名指</li><li>4：小指</li><li>255：所有手指</li></ul> |
| `joint_id` | <ul><li>0-3：各关节（0 → 3：近端 → 远端）</li><li>255：所有关节</li></ul> |

#### 关节名格式

[话题控制](#63-话题控制)使用完整关节名：`{hand_name}/finger{1-5}_joint{1-4}`

| 索引 | 关节名 (hand_name=hand_0) | 手指 |
|:-----|:--------------------------|:-----|
| 0-3 | hand_0/finger1_joint1~4 | 拇指 |
| 4-7 | hand_0/finger2_joint1~4 | 食指 |
| 8-11 | hand_0/finger3_joint1~4 | 中指 |
| 12-15 | hand_0/finger4_joint1~4 | 无名指 |
| 16-19 | hand_0/finger5_joint1~4 | 小指 |

#### 索引计算

```text
index = finger_id * 4 + joint_id
```

例如：食指（finger_id=1）第三关节（joint_id=2）的索引为 `1 * 4 + 2 = 6`。

## 6. ROS2 接口

### 6.1 接口清单

#### HandDiagnostics 消息

`wujihand_msgs/msg/HandDiagnostics`：硬件诊断信息，10Hz 发布。

```text
std_msgs/Header header
string handedness               # "left" 或 "right"
float32 system_temperature      # 系统温度 (°C)
float32 input_voltage           # 输入电压 (V)
float32[20] joint_temperatures  # 关节温度 (°C)
uint32[20] error_codes          # 错误码（0=正常）
bool[20] enabled                # 关节启用状态
float32[20] effort_limits       # Effort 限制设置 (A)
```

#### JointState 消息

`sensor_msgs/msg/JointState`：关节状态，1000Hz 发布。

| 字段 | 类型 | 说明 |
|:-----|:-----|:-----|
| `position` | `float64[20]` | 关节位置（弧度） |
| `velocity` | `float64[20]` | 未使用 |
| `effort` | `float64[20]` | 关节 Effort（安培） |

<Callout type="info">
**Effort 字段说明**

Effort 是电流空间的执行器作用量，经过滤波处理后输出。它不是实际测量的电流值，应将其理解为相对驱动强度。

典型应用场景：
- **碰撞检测**：effort 突增表示关节受阻
- **负载监控**：可通过 `effort / effort_limit` 计算当前输出百分比

默认 effort_limit 为 1.5A，最大 3.5A。
</Callout>

#### SetEnabled 服务

`wujihand_msgs/srv/SetEnabled`：启用或禁用关节。

```text
# Request
uint8 finger_id   # 0-4 或 255（所有手指）
uint8 joint_id    # 0-3 或 255（所有关节）
bool enabled      # true=启用, false=禁用
---
# Response
bool success
string message
```

#### ResetError 服务

`wujihand_msgs/srv/ResetError`：重置关节错误状态。

```text
# Request
uint8 finger_id   # 0-4 或 255（所有手指）
uint8 joint_id    # 0-3 或 255（所有关节）
---
# Response
bool success
string message
```

### 6.2 服务调用

#### 启用/禁用关节

```bash
# 禁用所有关节
ros2 service call /hand_0/set_enabled wujihand_msgs/srv/SetEnabled \
  "{finger_id: 255, joint_id: 255, enabled: false}"

# 启用所有关节
ros2 service call /hand_0/set_enabled wujihand_msgs/srv/SetEnabled \
  "{finger_id: 255, joint_id: 255, enabled: true}"

# 仅启用食指（finger_id=1）
ros2 service call /hand_0/set_enabled wujihand_msgs/srv/SetEnabled \
  "{finger_id: 1, joint_id: 255, enabled: true}"

# 仅启用拇指第一个关节
ros2 service call /hand_0/set_enabled wujihand_msgs/srv/SetEnabled \
  "{finger_id: 0, joint_id: 0, enabled: true}"
```

#### 重置错误

```bash
# 重置所有关节错误
ros2 service call /hand_0/reset_error wujihand_msgs/srv/ResetError \
  "{finger_id: 255, joint_id: 255}"
```

### 6.3 话题控制

#### 发送关节位置命令

关节位置通过 `/{hand_name}/joint_commands` 话题发送，使用 `sensor_msgs/msg/JointState` 消息类型。

**方式一：位置数组（20 个关节）**

```bash
# 所有关节归零
ros2 topic pub /hand_0/joint_commands sensor_msgs/msg/JointState \
  "{position: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]}" --once
```

**方式二：指定关节名**

```bash
# 仅控制食指的两个关节
ros2 topic pub /hand_0/joint_commands sensor_msgs/msg/JointState \
  "{name: ['hand_0/finger2_joint2', 'hand_0/finger2_joint3'], position: [1.0, 1.0]}" --once
```

#### 读取关节状态

```bash
# 读取一次关节状态（1000Hz 发布）
ros2 topic echo /hand_0/joint_states --once

# 读取诊断信息（10Hz 发布）
ros2 topic echo /hand_0/hand_diagnostics --once
```

### 6.4 代码示例

以下示例演示如何使用 JointState 消息控制灵巧手：
- 订阅 `joint_states` 话题，实时获取关节位置反馈
- 发布 `joint_commands` 话题，控制灵巧手运动

#### Python

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState

class WujiHandController(Node):
    """灵巧手控制节点，实现关节状态订阅和位置命令发布"""

    def __init__(self, hand_name='hand_0'):
        super().__init__('wujihand_controller')
        self.hand_name = hand_name

        # 创建发布者：向 joint_commands 话题发送关节位置命令
        self.cmd_pub = self.create_publisher(
            JointState,
            f'/{hand_name}/joint_commands',
            10  # 队列深度
        )

        # 创建订阅者：从 joint_states 话题接收关节状态（1000Hz）
        self.state_sub = self.create_subscription(
            JointState,
            f'/{hand_name}/joint_states',
            self.state_callback,
            10  # 队列深度
        )

    def state_callback(self, msg):
        """
        关节状态回调函数
        msg.position: 20 个关节的当前位置（弧度）
        msg.effort: 20 个关节的当前 effort（安培）
        """
        # 打印拇指的 4 个关节位置（索引 0-3）
        self.get_logger().info(f'Position: {msg.position[:4]}')

    def send_positions(self, positions):
        """
        发送关节位置命令
        positions: 长度为 20 的数组，对应 20 个关节的目标位置（弧度）
        """
        msg = JointState()
        msg.position = list(positions)
        self.cmd_pub.publish(msg)

def main():
    # 初始化 ROS2
    rclpy.init()

    # 创建控制节点
    node = WujiHandController(hand_name='hand_0')

    # 发送所有关节归零命令（20 个关节全部设为 0 弧度）
    node.send_positions([0.0] * 20)

    # 进入事件循环，持续接收关节状态
    rclpy.spin(node)

    # 清理资源
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### C++

```cpp
#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/joint_state.hpp>

/**
 * 灵巧手控制节点
 * 功能：订阅关节状态、发布位置命令
 */
class WujiHandController : public rclcpp::Node {
public:
    WujiHandController(const std::string& hand_name = "hand_0")
        : Node("wujihand_controller"), hand_name_(hand_name)
    {
        // 创建发布者：向 joint_commands 话题发送关节位置命令
        cmd_pub_ = this->create_publisher<sensor_msgs::msg::JointState>(
            "/" + hand_name_ + "/joint_commands", 10);

        // 创建订阅者：从 joint_states 话题接收关节状态（1000Hz）
        state_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(
            "/" + hand_name_ + "/joint_states", 10,
            std::bind(&WujiHandController::state_callback, this, std::placeholders::_1));
    }

    /**
     * 发送关节位置命令
     * @param positions 长度为 20 的数组，对应 20 个关节的目标位置（弧度）
     */
    void send_positions(const std::vector<double>& positions) {
        auto msg = sensor_msgs::msg::JointState();
        msg.position = positions;
        cmd_pub_->publish(msg);
    }

private:
    /**
     * 关节状态回调函数
     * msg->position: 20 个关节的当前位置（弧度）
     * msg->effort: 20 个关节的当前 effort（安培）
     */
    void state_callback(const sensor_msgs::msg::JointState::SharedPtr msg) {
        RCLCPP_INFO(this->get_logger(), "Received joint states");
    }

    std::string hand_name_;
    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr cmd_pub_;
    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr state_sub_;
};

int main(int argc, char** argv) {
    // 初始化 ROS2
    rclcpp::init(argc, argv);

    // 创建控制节点
    auto node = std::make_shared<WujiHandController>("hand_0");

    // 发送所有关节归零命令（20 个关节全部设为 0 弧度）
    node->send_positions(std::vector<double>(20, 0.0));

    // 进入事件循环，持续接收关节状态
    rclcpp::spin(node);

    // 清理资源
    rclcpp::shutdown();
    return 0;
}
```

## 7. 附录

### 7.1 故障排查

**Q: 设备被占用 (ERROR_BUSY)？**

先终止已有的驱动进程：

```bash
pkill -f wujihand_driver_node
pkill -f robot_state_publisher
ros2 launch wujihand_bringup wujihand.launch.py
```

**Q: 话题或服务列表不完整？**

ROS2 daemon 可能缓存了旧的节点信息：

```bash
# 重启 daemon
ros2 daemon stop
ros2 daemon start
sleep 2

# 重新查看
ros2 topic list
ros2 service list
```

或使用 `--no-daemon` 选项直接查询：

```bash
ros2 service list --no-daemon | grep -E "set_enabled|reset_error"
```

**Q: RViz 模型不显示？**

1. 确认 **Fixed Frame** 设置为 `{hand_name}/palm_link`（如 `hand_0/palm_link`）
2. 确认 **RobotModel** 的 **Description Topic** 设置为 `/{hand_name}/robot_description`
3. 检查关节状态是否正常：

```bash
ros2 topic echo /hand_0/joint_states --once
```

### 7.2 错误码参考

| 错误码 | 含义 | 处理方法 |
|:-------|:-----|:---------|
| 0 | 正常 | - |
| 1 | 过温保护 | 等待冷却后重试 |
| 2 | 过流保护 | 检查负载，调用 reset_error 服务 |
| 3 | 通信超时 | 检查 USB 连接，重启驱动 |

### 7.3 相关资源

- **GitHub 仓库**：[wuji-technology/wujihandros2](https://github.com/wuji-technology/wujihandros2)
- **Deb 包下载**：[GitHub Releases](https://github.com/wuji-technology/wujihandros2/releases)
- **Wuji Hand SDK**：[GitHub Releases](https://github.com/wuji-technology/wujihandpy/releases)
- **技术支持**：[support@wuji.tech](mailto:support@wuji.tech)
